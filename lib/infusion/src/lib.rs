//! Infusion is a dependency injection library to help with top-down approach to
//! software development by leveraging traits and generics.
//!
//! See the documentation for [`infu`] for more information. Additional implementation
//! detail notes can also be found in [`note`].
//!
//! ## Main Components
//!
//! There are 4 main parts that you should read about.
//!
//! | NAME     | Description |
//! | -------- | ----------- |
//! | [`infu`] | The main macro to generate the impl overwrite. |
//! | [`collection`] | The macro to generate a collection trait. |
//! | [`DependencyGraph`] | The concrete project model generated by a collection. |
//! | [`Container`] | The DI-provider. This is where instances of objects live. |
//!
//! ## Proc macros
//!
//! | [`blank`]  | The macro to put over a non-service trait to impl a blank impl. |
//! | [`service`]  | Turn a trait into a infusion service. |
//!
//! ## Utility macros
//!
//! There are also some utility macros:
//!
//! | NAME     | Description |
//! | -------- | ----------- |
//! | [`c`]    | This can be used to help with accessing the type on a collection. |
//! | [`tag`]  | This can be used to help generate a [`Tag`](vtable::Tag). |
//! | [`ok`]  | Can be used to create an infallible `Ok`. |
//!
//! # Example
//!
//! ```
#![doc = include_str!("../examples/graph.rs")]
//! ```

#![allow(clippy::all, unused)]

/// The implementation of macros.
mod macros2;

/// The error types.
pub mod error;

/// Notes on the implementation detail.
pub mod note;

/// The implementation of the virtual table and dynamic object.
pub mod vtable;

/// The implementation of the container.
pub mod container;

/// Project graph.
pub mod graph;

use std::future::Future;
use std::marker::PhantomData;

pub use container::Container;
pub use error::InitializationError;
pub use graph::DependencyGraph;
#[doc(hidden)]
pub use infusion_proc::{__blank_helper, __gen_macros_helper, __modifier_helper};
pub use infusion_proc::{blank, service};
#[doc(hidden)]
pub use paste::paste;
use serde::{Deserialize, Serialize};

/// The object that is meant to be the placeholder nullified implementer
/// of every generic trait.
#[derive(Copy, Serialize, Deserialize)]
pub struct Blank<C>(PhantomData<C>);

unsafe impl<C> Send for Blank<C> {}
unsafe impl<C> Sync for Blank<C> {}

impl<T> Default for Blank<T> {
    fn default() -> Self {
        Self(PhantomData)
    }
}

impl<T> Clone for Blank<T> {
    fn clone(&self) -> Self {
        Self(PhantomData)
    }
}

impl<T> Future for Blank<T> {
    type Output = T;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        log::error!(
            "infusion::Blank<{}> was awaited",
            std::any::type_name::<T>()
        );

        std::task::Poll::Pending
    }
}
