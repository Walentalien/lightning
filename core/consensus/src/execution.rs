use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};

use async_trait::async_trait;
use fastcrypto::hash::HashFunction;
use fleek_blake3 as blake3;
use lightning_interfaces::types::{Block, NodeIndex, UpdateRequest};
use lightning_interfaces::{ExecutionEngineSocket, PubSub, ToDigest, TranscriptBuilder};
use log::info;
use narwhal_crypto::DefaultHashFunction;
use narwhal_executor::ExecutionState;
use narwhal_types::{BatchAPI, BatchDigest, ConsensusOutput, Transaction};
use serde::{Deserialize, Serialize};
use tokio::sync::Notify;

use crate::consensus::PubSubMsg;

pub type Digest = [u8; 32];

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct AuthenticStampedParcel {
    pub transactions: Vec<Transaction>,
    pub last_executed: Digest,
}

impl ToDigest for AuthenticStampedParcel {
    fn transcript(&self) -> TranscriptBuilder {
        panic!("We don't need this here");
    }

    fn to_digest(&self) -> Digest {
        let batch_digest =
            BatchDigest::new(DefaultHashFunction::digest_iterator(self.transactions.iter()).into());

        let mut bytes = Vec::new();
        bytes.extend_from_slice(&(self.transactions.len() as u32).to_le_bytes());
        bytes.extend_from_slice(&batch_digest.0);
        bytes.extend_from_slice(&self.last_executed);

        blake3::hash(&bytes).into()
    }
}

/// A message an authority sends out attest that an Authentic stamp parcel is accurate. When an edge
/// node gets 2f+1 of these it commmits the transactions in the parcel
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CommitteeAttestation {
    /// The digest we are attesting is correct
    pub digest: Digest,
    /// We send random bytes with this messsage so it gives it a unique hash and differentiates it
    /// from the other committee members attestation broadcasts
    pub node_index: NodeIndex,
}

pub struct Execution<P: PubSub<PubSubMsg>> {
    /// Managing certificates generated by narwhal.
    executor: ExecutionEngineSocket,
    /// The node index of this node
    node_index: NodeIndex,
    /// Used to signal internal consensus proccesses that it is time to reconfigure for a new epoch
    reconfigure_notify: Arc<Notify>,
    /// Notifier that notifies everytime a block is executed on application state
    new_block_notify: Arc<Notify>,
    /// Pub sub used to send out parcels and attestations
    pub_sub: P,
    /// If this node is currently on the committee
    is_committee: AtomicBool,
    inner: Mutex<ExecutionInner>,
}

struct ExecutionInner {
    /// The digest of the last set of transactions we have executed
    last_executed: Option<Digest>,
}

impl ExecutionInner {
    fn new() -> Self {
        Self {
            last_executed: None,
        }
    }
}

impl<P: PubSub<PubSubMsg>> Execution<P> {
    pub fn new(
        executor: ExecutionEngineSocket,
        reconfigure_notify: Arc<Notify>,
        new_block_notify: Arc<Notify>,
        pub_sub: P,
        node_index: NodeIndex,
    ) -> Self {
        Self {
            executor,
            reconfigure_notify,
            new_block_notify,
            pub_sub,
            is_committee: AtomicBool::new(false),
            inner: Mutex::new(ExecutionInner::new()),
            node_index,
        }
    }

    /// This should only EVER be called in handle_consensus_output or
    pub(crate) async fn submit_batch(&self, payload: Vec<Transaction>) {
        let mut change_epoch = false;

        let transactions = payload
            .iter()
            .filter_map(|txn| bincode::deserialize::<UpdateRequest>(txn).ok())
            .collect::<Vec<_>>();

        let block = Block { transactions };

        // Unfailable
        let results = self.executor.run(block).await.unwrap();
        info!("Consensus submitted new block to application");

        if results.change_epoch {
            change_epoch = true;
        }

        self.new_block_notify.notify_waiters();
        if change_epoch {
            self.reconfigure_notify.notify_waiters();
        }
    }

    pub fn set_committee_status(&self, on_committee: bool) {
        self.is_committee.store(on_committee, Ordering::Relaxed)
    }
}

#[async_trait]
impl<P: PubSub<PubSubMsg>> ExecutionState for Execution<P> {
    async fn handle_consensus_output(&self, consensus_output: ConsensusOutput) {
        let mut batch_payload: Vec<Transaction> =
            Vec::with_capacity(consensus_output.sub_dag.num_batches());

        for (_, batches) in consensus_output.batches {
            // Put all the batches in this Consensus output into one vec of batches.
            for mut batch in batches {
                batch_payload.extend(batch.transactions_mut().to_owned());
            }
        }
        if !batch_payload.is_empty() {
            // Submit the batches to application layer
            self.submit_batch(batch_payload.clone()).await;

            // We have batches in the payload send them over broadcast along with an attestion of
            // them
            let last_digest = self.inner.lock().unwrap().last_executed.unwrap_or([0; 32]);

            let parcel = AuthenticStampedParcel {
                transactions: batch_payload,
                last_executed: last_digest,
            };
            let parcel_digest = parcel.to_digest();

            // Send out the transaction payload to application
            self.pub_sub.send(&parcel.into()).await;
            info!("Send transaction parcel to broadcast as a validator");

            let attestation = CommitteeAttestation {
                digest: parcel_digest,
                node_index: self.node_index,
            };
            // Send out that attestation that this payload is correct
            self.pub_sub.send(&attestation.into()).await;
            info!("Send parcel attestation to broadcast as a validator");

            // Update our last digest proccesed
            self.inner.lock().unwrap().last_executed = Some(parcel_digest);
        }
    }

    async fn last_executed_sub_dag_index(&self) -> u64 {
        0
    }
}

#[cfg(test)]
mod tests {
    use lightning_interfaces::ToDigest;
    use narwhal_types::{Batch, BatchAPI, Transaction};
    use rand::Rng;
    use sui_protocol_config::{Chain, ProtocolConfig, ProtocolVersion};

    use super::{AuthenticStampedParcel, Digest};

    fn generate_random_tx(length: usize) -> Transaction {
        let mut rng = rand::thread_rng();
        (0..length).map(|_| rng.gen_range(0..255)).collect()
    }

    fn generate_random_batch(num_txns: usize, tx_length: usize) -> Batch {
        let config =
            ProtocolConfig::get_for_version_if_supported(ProtocolVersion::new(12), Chain::Unknown)
                .unwrap();
        let txns = (0..num_txns)
            .map(|_| generate_random_tx(tx_length))
            .collect();
        Batch::new(txns, &config)
    }

    fn generate_random_parcel(
        num_batches: usize,
        num_txns: usize,
        tx_length: usize,
        last_executed: Option<Digest>,
    ) -> AuthenticStampedParcel {
        let transactions = (0..num_batches)
            .map(|_| {
                generate_random_batch(num_txns, tx_length)
                    .transactions()
                    .clone()
            })
            .flatten()
            .collect();
        AuthenticStampedParcel {
            transactions,
            last_executed: last_executed.unwrap_or([0; 32]),
        }
    }

    #[test]
    fn test_to_digest_eq() {
        let parcel = generate_random_parcel(5, 4, 10, None);
        assert_eq!(parcel.to_digest(), parcel.to_digest());
    }

    #[test]
    fn test_to_digest_ne() {
        let parcel1 = generate_random_parcel(5, 4, 10, None);
        let parcel2 = generate_random_parcel(5, 6, 10, None);
        let digest1 = parcel1.to_digest();
        let digest2 = parcel2.to_digest();
        assert_ne!(digest1, digest2);
    }

    #[test]
    fn test_to_digest_reorder_batches() {
        let parcel1 = generate_random_parcel(5, 4, 10, None);
        let mut parcel2 = parcel1.clone();
        let temp_batch = parcel2.transactions[1].clone();
        parcel2.transactions[1] = parcel2.transactions[0].clone();
        parcel2.transactions[0] = temp_batch;
        // Payloads with transactions in dif order should not have the same hash
        assert_ne!(parcel1.to_digest(), parcel2.to_digest());
    }
}
